#!/usr/bin/env python3

import argparse
import math
import sys
from pathlib import Path
from struct import *
from bin2h import bin2array
from donut import get_cblocks_from_bytes

def main(fin: Path, fout: Path):
  fout.mkdir(parents=True, exist_ok=True)

  # store a list of the chr tile count and offset
  # so we can import them as linker symbols
  chr_offset = {}
  chr_count = {}

  for file in (fin / "metasprites").rglob('*.msb'):
    
    # metasprites = ""
    # filename = file.stem.replace(".", "_").replace(" ", "_")
    with open(file, 'rb') as f:
      byts = f.read()
      grid_x = byts[0]
      grid_y = byts[1]
      out = []
      for metasprite in range(0, 256):
        sprites = []
        # estimate a box for the sprite to use for centering
        meta_width = 0
        # meta_height = 0
        for sprite in range(0, 64):
          spr_idx = 2 + metasprite * 256 + sprite * 4
          spr = byts[spr_idx:spr_idx+4]
          if (spr[0] == 0xff):
            break
          spr_y = spr[0] - grid_y
          spr_x = spr[3] - grid_x
          meta_width = max(int(math.log(spr_x + 8, 2)) * 2, meta_width)
          # meta_height = max(int(math.log(spr_y + 16, 2)) * 2, meta_width)


        for sprite in range(0, 64):
          # load the four bytes for this sprite from the bytes
          spr_idx = 2 + metasprite * 256 + sprite * 4
          spr = byts[spr_idx:spr_idx+4]

          # y, tile, attr, x
          if (spr[0] == 0xff):
            break

          spr_y = spr[0] - grid_y
          # since these are 8x16 sprites, we need to offset the tile id properly
          tile_id = spr[1] * 2 + 1
          attr = spr[2]
          # offset = 0
          # HACK move the up/down kitty sprite over a bit
          if file.stem == "kitty":
            if metasprite in range(4,8):
              meta_width = 24
            if metasprite in range(12,16):
              meta_width = 24
          spr_x = (spr[3] - grid_x) - meta_width // 2 + 1
          # NOTICE: we change the order slightly to allow skipping a sprite if its offscreen
          # print(f" {tile_id}, {attr}, {spr_y}, {spr_x}")
          sprites.append(pack("<BBbb", tile_id, attr, spr_y, spr_x))
        
        if len(sprites) == 0:
          continue
        o = b"\x7f" # terminal byte
        for spr in sprites:
          o += spr
        out.append(o)
        
        with open((fout / "sprites" / f"{file.stem}_metasprite_{metasprite}.bin"), 'wb') as single:
          single.write(o)

      # this is broken but it keeps cmake from rebuilding all the time for now.
      with open((fout / "sprites" / f"{file.stem}_metasprite.msb"), 'wb') as o:
        offset = len(out)
        for byt in out:
          offset += len(byt)
          # if (offset > 255):
          #   print(f"<ERROR> Total length of metasprites for {file.stem} is greater than 255", file=sys.stderr)
          #   exit(1)
          
          if (offset < 255):
            o.write(pack("<B", offset))
        for byt in out:
          o.write(byt)

    with open(fin / "metasprites" / f"{file.stem}.chr", 'rb') as f:
      rawchr = f.read()
      compressed_pages = []
      for block in get_cblocks_from_bytes(rawchr, allow_partial=True):
        compressed_pages.append(block)
      compressed = b''.join(compressed_pages)
      # chr = bin2array(filename + "_chr", compressed)
      r = len(rawchr)
      w = len(compressed)
      chr_offset[file.stem] = r
      chr_count[file.stem] = r // 16
      ratio = 1 - (w / r)
      print("<total> :{:>6.1%} ({} => {} bytes, {})".format(ratio, r, w, file.stem), file=sys.stderr)
      with open((fout / "sprites" / f"{file.stem}.chr.dnt"), 'wb') as o:
        o.write(compressed)
      with open((fout / "raw" / "sprites" / f"{file.stem}.chr"), 'wb') as o:
        o.write(rawchr)
        
  # write the asm file with all the CHR tile sizes and offsets
  asm_file = """
// Generated by process_background.py

#pragma once

#include <stdint.h>

// CHR offsets - ie the total number of bytes used by this block
"""
  for name,off in chr_offset.items():
    asm_file += f"""
constexpr uint16_t {name}_chr_offset = {off};
"""
  asm_file += """

// CHR count - ie the number of 8x8 tiles used by this block
"""
  for name,count in chr_count.items():
    asm_file += f"""
constexpr uint8_t {name}_chr_count = {count};
"""

  asm_file += f"""
// Max weapon offset/count
constexpr uint16_t weapon_chr_offset = {max([ x for name, x in chr_offset.items() if "weapon" in name])};
constexpr uint8_t weapon_chr_count = {max([ x for name, x in chr_count.items() if "weapon" in name])};
"""

  with open(fout / "header" / "sprites_constants.hpp", 'w') as out:
    out.write(asm_file)

  # generate the speed table

  with open(fout / "header" / "speed_table.bin", 'wb') as outbin,open(fout / "header" / "speed_table.hpp", 'w') as outhpp:
    all_data = []
    for i in [0.75, 1.0, 1.1, 1.44, 1.65, 1.90, 2.0, 2.2, 2.5, 3.0]:
      all_data += [float2fixed(i)]
    split = tuple(map(list, zip(*all_data)))
    speedname, x_hi, x_lo, xy_hi, xy_lo = split
    speednameout = ",\n\t".join(speedname)
    outhpp.write(f"""
// generated by process_metasprite.py
enum class Speed : unsigned char {{
    None,
    {speednameout},
    Count,
}};
""")
    for i in [x_lo, x_hi, xy_lo, xy_hi]:
      outbin.write(pack("<B", 0))
      for x in i:
        outbin.write(pack("<B", x))

def float2fixed(fl):
  x = int(fl * float(1 << 8))
  xl = int( fl * (1.0/math.sqrt(2)) * float(1 << 8) )
  return (
    f"s{fl:.2f}".replace(".","_"),
    (x >> 8) & 0xff,
    x & 0xff,
    (xl >> 8) & 0xff,
    xl & 0xff,
  )

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Processes Metasprites and outputs to header files')
  
  parser.add_argument('fin', metavar='in', type=str,
                      help='Input Directory of msb files to build the song data from')
  parser.add_argument('fout', metavar='out', type=str,
                      help='Build Directory to write the output files to.')
                      
  args = parser.parse_args()
  main(Path(args.fin).resolve(), Path(args.fout).resolve())
