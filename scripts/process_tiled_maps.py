#!/usr/bin/env python3

import argparse
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from struct import *

def parse_xml_room_object(root: ET.Element):
  objcollision = root.find('./objectgroup[@name="collision"]')
  collision = []
  for obj in objcollision.findall('object'):
    collision.append([
      int(obj.attrib["x"]),
      int(obj.attrib["y"]),
      int(obj.attrib["width"]),
      int(obj.attrib["height"]),
    ])
  return collision

def parse_xml_section_object(root: ET.Element, section: str):
  objexits = root.find('./objectgroup[@name="exit_spawns"]')
  section_exits = []
  for objname in [f"{section}_up", f"{section}_right", f"{section}_down", f"{section}_left"]:
    obj = objexits.find(f'object[@name="{objname}"]')
    if obj is not None:
      section_exits.append([
        int(obj.attrib["x"])//8%32,
        int(obj.attrib["y"])//8%30,
        int(obj.attrib["width"])//8,
        int(obj.attrib["height"])//8,
      ])
    else:
      section_exits.append([0,0,0,0])
  return section_exits
  # for objname in ["side_up", "side_right", "side_down", "side_left"]:
  #   obj = objexits.find(f'object[@name="{objname}"]')
  #   if obj is not None:
  #     print(ET.tostring(obj, encoding='unicode'))
  #     side_exits[i].append([
  #       int(obj.attrib["x"])//8%32,
  #       int(obj.attrib["y"])//8%30,
  #       int(obj.attrib["width"])//8,
  #       int(obj.attrib["height"])//8,
  #     ])
  #   else:
  #     side_exits[i].append([0,0,0,0])

def main(fin: Path, fout: Path):
  fout.mkdir(parents=True, exist_ok=True)

  # file_order = []
  # room_objects = []
  section_order = ["bottom", "left", "right", "single", "startdown", "startup", "top"]
  
  i = 0

  # for filename in ["leftright.tmx", "updown.tmx"]:
  #   # split out the files that have multiple boundaries
  #   root = ET.parse(fin / "tiled" / filename).getroot()
  
  section_collisions = []
  section_exits = []
  # side_exits = []

  for file in (fin / "tiled").rglob('*.tmx'):
    # file_order.append(f"{file.stem}")
    root = ET.parse(file).getroot()
    if file.stem == "updown":
      section_collisions.append( ("top", [x for x in parse_xml_room_object(root) if x[1] < 240]) )
      section_collisions.append( ("bottom", [x for x in parse_xml_room_object(root) if x[1] >= 240]) )
      section_exits.append( ("top", parse_xml_section_object(root, "up")) )
      section_exits.append( ("bottom", parse_xml_section_object(root, "down")) )
    elif file.stem == "leftright":
      section_collisions.append( ("left", [x for x in parse_xml_room_object(root) if x[0] < 256]) )
      section_collisions.append( ("right", [x for x in parse_xml_room_object(root) if x[0] >= 256]) )
      section_exits.append( ("left", parse_xml_section_object(root, "left")) )
      section_exits.append( ("right", parse_xml_section_object(root, "right")) )
    elif file.stem == "start":
      section_collisions.append( ("startup", [x for x in parse_xml_room_object(root) if x[1] < 240]) )
      section_collisions.append( ("startdown", [x for x in parse_xml_room_object(root) if x[1] >= 240]) )
      section_exits.append( ("startup", parse_xml_section_object(root, "up")) )
      section_exits.append( ("startdown", parse_xml_section_object(root, "down")) )
    elif file.stem == "single":
      section_collisions.append( ("single", parse_xml_room_object(root)) )
      section_exits.append( ("single", parse_xml_section_object(root, "single")) )

    # side_exits.append( parse_xml_section_object(root, "side") )
  section_collisions = [y[1] for y in sorted(section_collisions, key=lambda x: x[0])]
  section_exits = [y[1] for y in sorted(section_exits, key=lambda x: x[0])]

  nl = "\n"
  with open(fout / "header" / "room_collision.hpp", 'w') as header:
    hppfile = f"""
/// Generated by process_background.py

#pragma once

constexpr unsigned char section_object_collision_total = {sum(len(x) for x in section_collisions)};
"""
    for i, f in enumerate(section_order):
      hppfile += f"""
constexpr unsigned char section_object_collision_{f}_offset = {sum(len(x) for x in section_collisions[0:i])};"""
    header.write(hppfile)


  with open(fout / "header" / f"room_collision.s", 'w') as asm:
    asm.write(f"""
;;; Generated by process_tiled_maps.py
.section .prg_rom_1.section_collision_lut,"aR",@progbits
.globl section_collision_lut
section_collision_lut:
;; Section collision data
; x
{nl.join([".byte " + ",".join([f"{int(row[0])&0xff}" for row in col]) for col in section_collisions])}
; y
{nl.join([".byte " + ",".join([f"{int(row[1])&0xff}" for row in col]) for col in section_collisions])}
; width
{nl.join([".byte " + ",".join([f"{row[2]}" for row in col]) for col in section_collisions])}
; height
{nl.join([".byte " + ",".join([f"{row[3]}" for row in col]) for col in section_collisions])}

;; section exits
.section .prg_rom_1.section_exit_lut,"aR",@progbits
.globl section_exit_lut
section_exit_lut:
; x (nmt position)
{nl.join([".byte " + ",".join([f"{row[0]}" for row in col]) for col in section_exits])}
; y (nmt position)
{nl.join([".byte " + ",".join([f"{row[1]}" for row in col]) for col in section_exits])}
; width
{nl.join([".byte " + ",".join([f"{row[2]}" for row in col]) for col in section_exits])}
; height
{nl.join([".byte " + ",".join([f"{row[3]}" for row in col]) for col in section_exits])}

""")


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Processes Metasprites and outputs to header files')
  
  parser.add_argument('fin', metavar='in', type=str,
                      help='Input Directory of msb files to build the song data from')
  parser.add_argument('fout', metavar='out', type=str,
                      help='Build Directory to write the output files to.')
                      
  args = parser.parse_args()
  main(Path(args.fin).resolve(), Path(args.fout).resolve())
